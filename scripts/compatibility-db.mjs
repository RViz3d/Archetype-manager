/**
 * CompatibilityDB - Static compatibility database from Archetype Crawler data
 *
 * Provides pre-computed archetype compatibility data as a lookup layer
 * between JournalEntry fixes and regex auto-parsing.
 *
 * Priority chain: JE fixes > CompatibilityDB > Regex auto-parse > User prompt
 *
 * Data source: https://cbrayton.github.io/Archetype-Crawler/
 * Generated by: scripts/build-db.mjs
 */

import { MODULE_ID, debugLog } from './module.mjs';

export class CompatibilityDB {
  static _db = null;
  static _loading = null;

  /**
   * Load the compatibility database from the static JSON file.
   * Idempotent — subsequent calls return the cached DB.
   * @returns {Promise<boolean>} true if loaded successfully
   */
  static async load() {
    if (this._db) return true;
    if (this._loading) return this._loading;

    this._loading = (async () => {
      try {
        const modulePath = `modules/${MODULE_ID}/data/archetype-db.json`;
        const resp = await fetch(modulePath);
        if (!resp.ok) {
          debugLog(`${MODULE_ID} | CompatibilityDB: Failed to load (${resp.status}), falling back to regex-only mode`);
          return false;
        }
        this._db = await resp.json();
        debugLog(`${MODULE_ID} | CompatibilityDB: Loaded ${this._db.stats?.archetypes || '?'} archetypes across ${this._db.stats?.classes || '?'} classes`);
        return true;
      } catch (e) {
        debugLog(`${MODULE_ID} | CompatibilityDB: Load error, falling back to regex-only mode`, e);
        return false;
      } finally {
        this._loading = null;
      }
    })();

    return this._loading;
  }

  /**
   * Check if the DB is loaded
   * @returns {boolean}
   */
  static isLoaded() {
    return this._db !== null;
  }

  /**
   * Get a specific archetype entry
   * @param {string} className - Class name (case-insensitive)
   * @param {string} archetypeSlug - Archetype slug
   * @returns {object|null} { name, touched, touchedRaw, compatible } or null
   */
  static getArchetype(className, archetypeSlug) {
    if (!this._db) return null;
    const classKey = className.toLowerCase().trim();
    const classData = this._db.classes?.[classKey];
    if (!classData) return null;

    // Try direct slug match first
    if (classData[archetypeSlug]) return classData[archetypeSlug];

    // Try normalizing the slug (strip class prefix if present, e.g. "fighter-two-handed-fighter")
    const stripped = archetypeSlug.replace(new RegExp(`^${classKey}-`), '');
    if (classData[stripped]) return classData[stripped];

    // Try matching by extracting short name from "Class (ArchetypeName)" slug format
    // e.g., "fighter-two-handed-fighter" → try "two-handed-fighter"
    const shortMatch = archetypeSlug.match(/^[a-z]+-(.+)$/);
    if (shortMatch && classData[shortMatch[1]]) return classData[shortMatch[1]];

    return null;
  }

  /**
   * Get normalized touched feature series for an archetype
   * @param {string} className
   * @param {string} archetypeSlug
   * @returns {string[]|null} Normalized series base names
   */
  static getTouched(className, archetypeSlug) {
    return this.getArchetype(className, archetypeSlug)?.touched ?? null;
  }

  /**
   * Get raw touched feature names for an archetype
   * @param {string} className
   * @param {string} archetypeSlug
   * @returns {string[]|null} Original feature names from Crawler data
   */
  static getTouchedRaw(className, archetypeSlug) {
    return this.getArchetype(className, archetypeSlug)?.touchedRaw ?? null;
  }

  /**
   * Get compatible archetype slugs
   * @param {string} className
   * @param {string} archetypeSlug
   * @returns {string[]|null} Slugs of compatible archetypes, or null if not in DB
   */
  static getCompatible(className, archetypeSlug) {
    return this.getArchetype(className, archetypeSlug)?.compatible ?? null;
  }

  /**
   * Check if two archetypes are compatible using pre-computed pairs.
   * Returns null if either archetype is not in the DB (unknown compatibility).
   * @param {string} className
   * @param {string} slugA
   * @param {string} slugB
   * @returns {boolean|null} true=compatible, false=incompatible, null=unknown
   */
  static areCompatible(className, slugA, slugB) {
    const entryA = this.getArchetype(className, slugA);
    const entryB = this.getArchetype(className, slugB);

    // If either archetype is not in DB, we can't determine compatibility
    if (!entryA || !entryB) return null;

    // Check A's compatible list for B
    const compatA = entryA.compatible || [];
    // Need to check both the exact slug and possible variations
    const slugBShort = this._extractShortSlug(slugB, className);
    const slugAShort = this._extractShortSlug(slugA, className);

    if (compatA.includes(slugB) || compatA.includes(slugBShort)) return true;

    // Check B's compatible list for A (symmetry check)
    const compatB = entryB.compatible || [];
    if (compatB.includes(slugA) || compatB.includes(slugAShort)) return true;

    // Both in DB but neither lists the other → incompatible
    return false;
  }

  /**
   * Check if a class exists in the DB
   * @param {string} className
   * @returns {boolean}
   */
  static hasClass(className) {
    if (!this._db) return false;
    return className.toLowerCase().trim() in (this._db.classes || {});
  }

  /**
   * Get all archetype entries for a class
   * @param {string} className
   * @returns {object|null} Map of slug → entry
   */
  static getArchetypesForClass(className) {
    if (!this._db) return null;
    return this._db.classes?.[className.toLowerCase().trim()] ?? null;
  }

  /**
   * Extract the short slug from a potentially prefixed slug
   * @private
   */
  static _extractShortSlug(slug, className) {
    const prefix = className.toLowerCase().trim() + '-';
    if (slug.startsWith(prefix)) return slug.slice(prefix.length);
    return slug;
  }
}
